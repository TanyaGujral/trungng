// Copyright (C) 2010 U&I Lab, CS Dept., KAIST.

package edu.kaist.uilab.contagts.server;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.jdo.annotations.Extension;
import javax.jdo.annotations.IdGeneratorStrategy;
import javax.jdo.annotations.NotPersistent;
import javax.jdo.annotations.PersistenceCapable;
import javax.jdo.annotations.Persistent;
import javax.jdo.annotations.PrimaryKey;

import com.google.appengine.api.datastore.Key;

import edu.kaist.uilab.contagts.server.servlet.ServletUtils;

/**
 * A contact (or a resource, more appropriately) that is shared by one of the users.
 *
 * <p> Each contact is uniquely determined by either an email or a phone number although
 * its primary key is automatically generated by the datastore. Application should take
 * careful practice in maintaining this consistency.
 * 
 * <p> This entity is searchable by contacts.
 * 
 * @author Trung Nguyen (trung.ngvan@gmail.com)
 */
@PersistenceCapable
public class SharableContact {
	
	public static final String NAME = "name";
	public static final String EMAIL = "email";
	public static final String NUMBER = "number";
	public static final String ADDRESS = "address";
	public static final String LABEL = "labels";
	public static final String PERSON = "person";
	public static final String CITY = "city";
	
  @PrimaryKey
  @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
  private Key key;

  @Persistent
  private boolean isPublic; // whether this contact is public
  
  @Persistent
  private String email;
  
  @Persistent
  private String number;
  
  @Persistent
	@Extension(vendorName = "datanucleus", key = "gae.unindexed", value = "true")
  private String name; // display name of this contact
  
  @Persistent
	@Extension(vendorName = "datanucleus", key = "gae.unindexed", value = "true")
  private String address; // address of this contact

  @Persistent
  private String city;
  
	@Persistent
	@Extension(vendorName = "datanucleus", key = "gae.unindexed", value = "true")
	private List<Label> labels; // labels that this contact was annotated with
	
	@Persistent
	private List<String> stringLabels;
	
	@Persistent
	@Extension(vendorName = "datanucleus", key = "gae.unindexed", value = "true")
	private List<Group> groups; // groups that can see this contact

	@NotPersistent
	private float score;
	
	@NotPersistent
	private List<String> people;
	
	/**
	 * Constructor
	 * 
	 * @param email email of this contact
	 * @param name name of this contact
	 * @param number phone number of this contact
	 * @param address address of this contact
	 * @param city city of this contact (assuming that it is the same as that of the
	 * 			the person who shared this contact)
	 */
	public SharableContact(String email, String name, String number,
			String address, String city) {
		this.isPublic = false;
		this.email = email;
		this.name = name;
		this.number = number;
		this.address = address;
		this.city = city;
		this.labels = new ArrayList<Label>();
		this.stringLabels = new ArrayList<String>();
		this.groups = new ArrayList<Group>();
	}
	
	/**
	 * Constructor
	 * 
	 * <p> This constructor copies all instance variables of {@code contact}.
	 * @param c
	 */
	public SharableContact(SharableContact contact, float score) {
		this.key = contact.key;
		this.email = contact.email;
		this.name = contact.name;
		this.number = contact.number;
		this.address = contact.address;
		this.score = score;
	}

	public Key getKey() {
		return key;
	}

	public void setKey(Key key) {
		this.key = key;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getNumber() {
		return number;
	}

	public void setNumber(String phoneNumber) {
		this.number = phoneNumber;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Returns the list of labels for this contact.
	 * 
	 * <p> This list is different from the list returned by {@link #getLabels()} in
	 * that all labels are single words.
	 * 
	 * @return
	 */
	public List<String> getStringLabels() {
		return stringLabels;
	}
	
	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	public void setStringLabels(List<String> list) {
		this.stringLabels = list;
	}
	
	public List<Label> getLabels() {
		return labels;
	}

	/**
	 * Updates the list of string labels for this contact.
	 * 
	 * <p> For the database to be consistent, this method must be call whenever
	 * you make change to the list returned by {@link #getLabels()}.
	 * 
	 */
	public void updateStringLabels() {
		stringLabels = new ArrayList<String>();
		for (Label label : labels) {
			stringLabels.addAll(Arrays.asList(label.getLabel().split(" ")));
		}
	}
	
	/**
	 * Sets {@code labels} to be the list of labels for this entity.
	 * 
	 * <p> For the persistence manager to see any change in data, the given
	 * {@code labels} must be different from the one returned by {@link #getLabels()},
	 * i.e., their memory references must not be the same.
	 * 
	 * @param labels
	 */
	public void setLabels(List<Label> labels) {
		this.labels = labels;
	}
	
	public List<Group> getGroups() {
		return groups;
	}

	/**
	 * Sets {@code groups} to be the list of groups for this entity.
	 * 
	 * <p> For the persistence manager to see any change in data, the given
	 * {@code groups} must be different from the one returned by {@link #getGroups()},
	 * i.e., their memory references must not be the same.
	 * 
	 * @param groups
	 */
	public void setGroups(List<Group> groups) {
		this.groups = groups;
	}
	
	public boolean isPublic() {
		return isPublic;
	}
	
	/**
	 * Makes this contact publicly searchable.
	 */
	public void makePublic() {
		isPublic = true;
	}
	
	/**
	 * Returns true if this contact is visible to the ContactEntity {@code c}. In other
	 * words, {@code c} is allowed to see this contact by some of its friends.
	 * 
	 * <p> If this contact is public, returns true for every {@code ContactEntity}.
	 * @param c
	 * @return
	 */
	public boolean isVisibleTo(ContactEntity c) {
		if (isPublic) {
			return true;
		}
		
		// if c is the person who shares this contact
		for (Label label : this.labels) {
			if (label.getDeviceId().equals(c.getDeviceId())) {
				return true;
			}
		}
		
		// if c is granted to see this contact by some of its friend
		List<Label> labels = c.getLabels();
		for (Group group : groups) {
			for (Label label : labels) {
				if (label.getDeviceId().equals(group.getDeviceId())
						&& label.getLabel().equals(group.getLabel())) {
					return true;
				}
			}
		}
		return false;
	}
	
	/**
	 * Returns true if this contact was tagged by {@code deviceId}.
	 * 
	 * @param c
	 * @return
	 */
	public boolean taggedBy(String deviceId) {
  	for (Label label : labels) {
  		if (label.getDeviceId().equals(deviceId)) {
  			return true;
  		}
  	}
  	
  	return false;
	}
	
	/**
	 * Sets value of score which indicates the relatedness between a particular
	 * search query and this contact's list of {@code labels}. This is primarily
	 * used for ranking when search.
	 * 
	 * @param score
	 */
	public void setScore(float score) {
		this.score = score;
	}
	
	public float getScore() {
		return score;
	}
	
	/**
	 * Adds a person to the list of people who either tagged or called this contact.
	 * 
	 * <p> The person is identify by his {@code number}.
	 * 
	 * <p> This method should be strictly used for returning a search result.
	 * 
	 * @param number
	 */
	public void addPerson(String number) {
		if (people == null) {
			people = new ArrayList<String>();
		}
		if (number != null) {
			people.add(number);
		}
	}
	
	/**
	 * Returns the list of people who either tagged or called this contact.
	 * 
	 * <p> The people are identified by their phone numbers.
	 * 
	 * <p> This method should be strictly used for returning search result.
	 * 
	 * @return
	 */
	public List<String> getPeople() {
		return people;
	}

	public void setCity(String city) {
		this.city = city;
	}

	public String getCity() {
		return city;
	}

	/**
	 * Returns the string representation of the list of labels annotated for
	 * this contact.
	 * 
	 * <p> This method should be strictly used for returning search result.
	 * 
	 * @return
	 */
	public String getStringOfLabels() {
		StringBuilder builder = new StringBuilder();
		for (Label label : labels) {
			builder.append(label.getLabel()).append(",");
		}
		if (builder.length() > 0) {
			builder.deleteCharAt(builder.length() - 1);
		}
		
		return builder.toString();
	}
	
	@Override
	public boolean equals(Object that) {
		SharableContact c = (SharableContact) that;
		return (this.key.equals(c.key));
	}
	
	@Override
	public int hashCode() {
		return key.hashCode();
	}
	
	@Override
	public String toString() {
		return isPublic + "," + score + "," + name + "," + email + "," + number + "," + address + "," + 
				ServletUtils.toString(labels) + "," + ServletUtils.toString(groups);
	}
}
